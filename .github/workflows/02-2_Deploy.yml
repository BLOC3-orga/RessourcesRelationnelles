name: 02-2 - Deploy

on:
  workflow_call

env:
  IMAGE_NAME_LOWER: ${{ github.repository }}

jobs:
  AzureDeploy:
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: http://${{ secrets.AZURE_HOST }}:8080
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Database Backup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.AZURE_HOST }}
          username: ${{ secrets.AZURE_LOGIN }}
          port: ${{ secrets.AZURE_PORT }}
          password: ${{ secrets.AZURE_PWD }}
          script: |
            echo "üíæ Creating database backup..."
            BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).bak"
            
            # V√©rifier si le conteneur de base de donn√©es existe
            if docker ps -a --format "{{.Names}}" | grep -q "r2_database"; then
              docker exec r2_database /opt/mssql-tools/bin/sqlcmd \
                -S localhost -U sa -P "${{ secrets.DB_PASSWORD }}" \
                -Q "BACKUP DATABASE [RessourcesRelationnelles] TO DISK = '/var/opt/mssql/data/$BACKUP_FILE'" \
                || echo "‚ö†Ô∏è Database backup failed, but continuing deployment"
              
              # Garder seulement les 5 derni√®res sauvegardes
              docker exec r2_database find /var/opt/mssql/data -name "backup_*.bak" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | head -n -5 | cut -d' ' -f2- | xargs rm -f || true
            else
              echo "‚ö†Ô∏è Database container not found, skipping backup"
            fi

      - name: Update Compose File
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.AZURE_HOST }}
          username: ${{ secrets.AZURE_LOGIN }}
          port: ${{ secrets.AZURE_PORT }}
          password: ${{ secrets.AZURE_PWD }}
          source: "./docker-compose.yml"
          target: "/opt/ressources-relationnelles/"

      - name: Deploy Application
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.AZURE_HOST }}
          username: ${{ secrets.AZURE_LOGIN }}
          port: ${{ secrets.AZURE_PORT }}
          password: ${{ secrets.AZURE_PWD }}
          script: |
            cd /opt/ressources-relationnelles
            
            # Login Docker Registry
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull nouvelle image
            NEW_IMAGE="ghcr.io/${{ env.IMAGE_NAME_LOWER }}:main-${{ github.sha }}"
            echo "üê≥ Pulling new image: $NEW_IMAGE"
            docker pull $NEW_IMAGE
            
            # Cr√©er une copie de sauvegarde du compose actuel
            cp docker-compose.yml docker-compose.yml.backup
            
            # Mise √† jour docker-compose avec nouvelle image
            sed -i "s|build:|#build:|g" docker-compose.yml
            sed -i "s|context: \.|#context: .|g" docker-compose.yml
            sed -i "s|dockerfile: R2\.UI/Dockerfile|#dockerfile: R2.UI/Dockerfile|g" docker-compose.yml
            sed -i "/r2-ui:/a\\    image: $NEW_IMAGE" docker-compose.yml
            
            echo "üìã Updated docker-compose.yml:"
            cat docker-compose.yml
            
            # D√©ploiement rolling update
            echo "üöÄ Starting rolling deployment..."
            docker-compose up -d --no-deps r2-ui
            
            # Attendre que le nouveau conteneur soit pr√™t
            echo "‚è≥ Waiting for application to be ready..."
            sleep 30
            
            # Health check simple
            for i in {1..10}; do
              if curl -f http://localhost:8080/ > /dev/null 2>&1; then
                echo "‚úÖ Application is responding!"
                break
              elif [ $i -eq 10 ]; then
                echo "‚ùå Application health check failed after 10 attempts"
                echo "üîÑ Rolling back to previous version..."
                
                # Rollback automatique
                cp docker-compose.yml.backup docker-compose.yml
                docker-compose up -d --no-deps r2-ui
                
                echo "‚ùå Deployment failed and rolled back"
                exit 1
              else
                echo "‚è≥ Attempt $i/10: Application not ready yet, waiting..."
                sleep 10
              fi
            done
            
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Application available at: http://${{ secrets.AZURE_HOST }}:8080"

  PostDeploymentTests:
    runs-on: ubuntu-latest
    needs: AzureDeploy
    steps:
      - name: Production Health Checks
        run: |
          echo "üîç Running post-deployment validation..."
          
          # Test endpoint principal
          echo "Testing main endpoint..."
          HTTP_CODE=$(curl -o /dev/null -s -w "%{http_code}" http://${{ secrets.AZURE_HOST }}:8080/)
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ Main endpoint accessible (HTTP $HTTP_CODE)"
          else
            echo "‚ùå Main endpoint test failed (HTTP $HTTP_CODE)"
            exit 1
          fi
          
          # Test temps de r√©ponse
          echo "Testing response time..."
          RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" http://${{ secrets.AZURE_HOST }}:8080/)
          echo "Response time: ${RESPONSE_TIME}s"
          
          # V√©rifier que le temps de r√©ponse respecte le SLA (< 2 secondes selon le rapport PDF)
          if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
            echo "‚ö†Ô∏è Response time exceeds SLA (>2s): ${RESPONSE_TIME}s"
            # Ne pas faire √©chouer le d√©ploiement, juste alerter
          else
            echo "‚úÖ Response time within SLA: ${RESPONSE_TIME}s"
          fi
          
          echo "‚úÖ Post-deployment tests completed successfully!"
          echo "üéØ Deployment Summary:"
          echo "  - Application: ‚úÖ Running"
          echo "  - Endpoint: ‚úÖ Accessible"
          echo "  - Response time: ${RESPONSE_TIME}s"
          echo "  - URL: http://${{ secrets.AZURE_HOST }}:8080"